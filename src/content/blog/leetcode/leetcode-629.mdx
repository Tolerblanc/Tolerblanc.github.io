---
title: '[LeetCode] 629. K Inverse Pairs Array'
excerpt: 리트코드 629 DP - 파이썬(Python) 풀이
date: 2024-01-27T00:00:00.000Z
categories:
  - LeetCode
tags:
  - Python
  - PS
  - DP
toc: true
tocDepth: 3
draft: false
lang: ko
author: Tolerblanc
updatedDate: 2024-01-27T00:00:00.000Z
description: 리트코드 629 DP - 파이썬(Python) 풀이
---

<Notice type="info">
👨‍💻 개인 공부 기록용 블로그 입니다. 

💡 틀린 내용이나 오타는 댓글, 메일로 제보해주시면 감사하겠습니다!!  (__)
</Notice>

# 링크

[https://leetcode.com/problems/k-inverse-pairs-array/?envType=daily-question&envId=2024-01-27](https://leetcode.com/problems/k-inverse-pairs-array/?envType=daily-question&envId=2024-01-27)

# 문제

![문제](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/14871a13-e554-4f89-861d-8002589688a6)


# 문제 설명 및 요점

- `Inverse Pair`는 인덱스는 증가하지만 값은 감소하는 형태의 숫자 쌍을 뜻한다.
- 1~ $ n $ 까지의 숫자가 있을 때, $ k $ 의 `Inverse Pair` 를 갖는 숫자 배치 경우의 수를 찾아야 한다.
- 정답이 클 수 있으니 $ 10^9 + 7 $ 로 나눈 나머지를 반환한다.

# 풀이

- [조합론에서의 오일러 수](https://ko.wikipedia.org/wiki/%EC%98%A4%EC%9D%BC%EB%9F%AC_%EC%88%98_(%EC%A1%B0%ED%95%A9%EB%A1%A0)) 개념을 확장한 문제. 오일러 수는 연속되는 인덱스에서 감소하는 쌍에 해당하는 순열이고, 문제에서는 인덱스의 연속 조건이 빠져있다.
- 그래도 오일러 수 보다는 점화식 찾기가 쉬운 편이지만, 그럼에도 너무 어렵다...
- 각 $ n $ 에 대해, $ k $ 는 $ _nC_2 $ 까지 존재할 수 있다. 
	- `Inverse Pair`가 가장 많이 존재할 수 있는 경우를 생각해보자.
	- 완벽하게 내림차순으로 정렬 되었을 때: `[n, n-1, ..., 2, 1]`
	- 위 경우에서 `Inverse Pair`는 $ n $ 개의 숫자에서 2개의 숫자를 순서 고려 없이 뽑은 경우의 수와 같다.
- 또한, 각 $ n $ 에 대해 모든 $ k $ 를 합치면 $ n! $이 나온다. ( $ n $개의 숫자를 나열하는 경우의 수)
- $ n=2 $ 에서 출발해보자. `[1,2]` ( $ k=0 $ )와 `[2,1]`( $ k=1 $ ) 두 경우가 존재한다.
- $ n=3 $ 일 때, $ 0 \le k \le 3 $  이다. $ k=0 $ 일 때는 항상 1이므로, 나머지 경우에 대해 생각해보자.
	- $ k=1 $ 인 경우, `[1,2]` $ (n=2,k=0) $ 인 경우에서 3을 중간에 끼워 넣거나, `[2,1]` $ (n=2,k=1) $ 인 경우에서 3을 맨 뒤에 끼워 넣는 경우 밖에 없다.
	- $ k=2 $인 경우, `[1,2]` \$ (n=2,k=0) $ 인 경우에서 3을 맨 앞에 끼워 넣거나, `[2,1]` $ (n=2,k=1) $ 인 경우에서 3을 중간에 끼워 넣는 경우 밖에 없다.
	- $ k=3 $인 경우, `[2,1]` $ (n=2,k=1) $ 인 경우에서 3을 맨 앞에 끼워 넣는 경우 밖에 없다.
- $ n=2 $ -> $ n=3 $ 을 만드는 원리가 보이는가? $ n=2 $ 인 경우의 수에서 3을 어떻게 끼우느냐에 달려있다. 
	- 표기를 간소화하기 위해 $ (n,k) $ 형태로 표기하겠다.
	- $ (2,0) $ 은 $ (3, 0), (3, 1), (3, 2) $에 관여한다. 
	- $ (2,1) $ 은 $ (3, 1), (3, 2), (3, 3) $에 관여한다.
    - 시각화 하면 이와 같다.
    ![image](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/e7770545-6066-42a4-928a-e2bfa1c50d84)

- $ n=3 $ -> $ n=4 $ 도 만들어보자. $ n=3 $ 인 경우의 수에서 4를 어떻게 끼울지 생각해보면 아래와 같은 결과를 얻을 수 있다.
	- 표기를 간소화하기 위해 $ (n,k) $ 형태로 표기하겠다.
	- $ (3, 0) $은 $ (4, 0), (4, 1), (4, 2), (4, 3) $에 관여한다.
	- $ (3, 1) $은 $ (4, 1), (4, 2), (4, 3), (4, 4) $에 관여한다.
	- $ (3, 2) $은 $ (4, 2), (4, 3), (4, 4), (4, 5) $에 관여한다.
	- $ (3, 3) $은 $ (4, 3), (4, 4), (4, 5), (4, 6) $에 관여한다.
    - 시각화 하면 이와 같다.
    ![image](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/ea99f571-5741-425f-9b4d-df1a0b56a19d)

- 수열이 만들어지는 원리는 이게 다인데, 이걸 그대로 구현하면 시간초과가 발생한다. $ n $ 개의 숫자에 대해 $ k $ 개의 숫자를 다음 수열에 $ n+1 $ 번 누적시켜줘야 하므로, $ O(N^2K) $ 라서 해결할 수 없다.
- 따라서 계산을 최적화해야 한다. 다시 위 시각화를 끌고 와서 생각해보자.
	- 표기를 간소화하기 위해 $ (n,k) $ 형태로 표기하겠다.
	- $ (4,2) $ 가 어떻게 만들어지는지 자세히 살펴보자.
    ![image](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/57f243be-226e-4ce9-9495-f97a333e76d0)
    - $ (4,2) $ 는 빨간 직선 하나, 초록 직선 하나, 파란 직선 하나로 구성되어 있다.
    - $ (4,1) $ 은 빨간 직선 하나, 초록 직선 하나로 구성되어 있다.
    - 따라서 $ (4,2) = (3, 0) + (3, 1) + (3, 2) = (4, 1) + (3, 2) $ 이다. 
    - 마치 조합의 성질 처럼, $ (n, k) = (n, k -1) + (n - 1, k) $ 를 통해 계산을 최적화 할 수 있다. 
    - 다만, 이는 $ k < n $ 인 경우에만 성립한다. 나머지는 대칭성을 이용해 계산해야 한다.
    - $ (4,3), (4,4) $ 에 집중해보자.
    ![image](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/68e1be1a-5a1c-4298-8d26-07647ae518ca)
    - $ (4,3) $ 은 빨강, 초록, 파랑, 노랑으로 구성되어 있다.
    - $ (4,4) $ 는 초록, 파랑, 노랑으로 구성되어 있다.
    - 따라서 $ (4, 4) = (4,3) + (3, 4) - (3, 0) $ 이다.
    - 나머지 경우도 확장해보면, $ k \ge n $ 인 경우에 대해 $ (n, k) = (n , k - 1) + (n - 1, k) - (n - 1, k-n) $ 이 성립함을 알 수 있다.
- 정리하면, 최종 점화식은 다음과 같다.
	- 표기를 간소화하기 위해 $ (n,k) $ 형태로 표기하겠다.  $ n \ge 2 $ 에서
	- $ k < n $ 인 경우에 대해, $ (n, k) = (n, k -1) + (n - 1, k) $
	- $ k \ge n $ 인 경우에 대해, $ (n, k) = (n , k - 1) + (n - 1, k) - (n - 1, k-n) $
	- 점화식을 그대로 재귀로 구현해도 정답을 받을 수 있다.
	- 생 재귀로는 당연히 불가능하고, 이전 값을 저장해두어야 한다. 파이썬의 경우 `@cache` 데코레이터를 사용하면 쉽게 구현할 수 있다.
- 좀 더 최적화를 시켜보자.
	- $ n=1 $ 일 때 부터 시작한다. $ (1, 0) $ 은 1이다.
	- $ k + 1 $ 칸 짜리 배열을 하나 준비하고, 빈 배열과 이전 값을 누적할 변수를 하나 둔다.
	- 누적값을 빈 배열에 계속 추가해 나가다가, $ k \ge n + 1 $ 이 되는 시점부터 누적값에서 `dp[k - n - 1]` 을 뺀다.
	- $ _nC_2 $ 를 전부 계산할 필요 없이, $k$까지만 계산한 후 `dp` 배열과 교체해준다.
	- 코드로 옮기면 아래와 같다. $ 10^9 + 7 $ 과의 나머지 연산을 잊지 말자.


# 코드

```python
class Solution:
    def kInversePairs(self, n: int, k: int) -> int:
        MOD = 10 ** 9 + 7
        dp = [0] * (k + 1)
        dp[0] = 1
        
        for i in range(n):
            temp, number = [], 0
            for j in range(k + 1):
                number += dp[j]
                if j-i >= 1: number -= dp[j-i-1]
                number %= MOD
                temp.append(number)
            dp = temp
        return dp[k]
```
