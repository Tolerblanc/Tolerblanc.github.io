---
import { cn } from "@/lib/utils";

export interface Heading {
  depth: number;
  slug: string;
  text: string;
}

interface Props {
  headings: Heading[];
}

const { headings } = Astro.props;

// depth 2, 3만 표시 (h2, h3)
const filteredHeadings = headings.filter(h => h.depth >= 2 && h.depth <= 3);
---

{filteredHeadings.length > 0 && (
  <nav class="w-64 rounded-lg border bg-card text-card-foreground shadow-sm sticky top-24 max-h-[calc(100vh-8rem)] flex flex-col pointer-events-none" aria-label="목차">
    <div class="p-4 border-b flex-shrink-0">
      <h2 class="text-sm font-semibold tracking-wide uppercase text-muted-foreground">목차</h2>
    </div>
    <ul id="toc-list" class="p-2 flex flex-col gap-1 overflow-y-scroll min-h-0 flex-1 custom-scrollbar pointer-events-auto overscroll-contain">
      {filteredHeadings.map((heading) => (
        <li class={cn("relative", heading.depth === 3 && "pl-4")}>
          <a
            href={`#${heading.slug}`}
            class="toc-link block px-3 py-2 text-sm text-muted-foreground rounded-md transition-colors hover:bg-muted hover:text-foreground line-clamp-2"
            data-heading-id={heading.slug}
          >
            {heading.text}
          </a>
        </li>
      ))}
    </ul>
  </nav>
)}

<script>
  // TOC 스크롤 스파이 (현재 섹션 하이라이트)
  class TableOfContents {
    private tocLinks: NodeListOf<HTMLAnchorElement>;
    private headings: HTMLElement[];
    private activeLink: HTMLAnchorElement | null = null;
    private observer!: IntersectionObserver;

    constructor() {
        this.tocLinks = document.querySelectorAll('.toc-link');
        this.headings = Array.from(document.querySelectorAll('h2[id], h3[id]'));
        
        if (this.headings.length === 0 || this.tocLinks.length === 0) return;

        const observerOptions = {
            rootMargin: '-100px 0px -66% 0px',
            threshold: [0, 1]
        };

        this.observer = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
                if (entry.isIntersecting) {
                    this.setActive(entry.target.id);
                }
            });
        }, observerOptions);

        this.headings.forEach((heading) => this.observer.observe(heading));
        
        // Smooth scroll on click
        this.tocLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const id = link.getAttribute('href')?.slice(1);
                const target = document.getElementById(id!);
                if (target) {
                    // Update URL without jump
                    history.pushState(null, '', `#${id}`);
                    
                    // Smooth scroll with offset for sticky header
                    const headerOffset = 100;
                    const elementPosition = target.getBoundingClientRect().top;
                    const offsetPosition = elementPosition + window.scrollY - headerOffset;

                    window.scrollTo({
                        top: offsetPosition,
                        behavior: "smooth"
                    });
                    
                    this.setActive(id!);
                }
            });
        });
    }

    private setActive(id: string) {
        // Remove active state from ALL links
        this.tocLinks.forEach(link => {
            link.classList.remove('bg-primary/5', 'text-primary', 'font-medium', 'border-l-2', 'border-primary');
            link.classList.add('text-muted-foreground');
        });

        const link = document.querySelector(`.toc-link[data-heading-id="${id}"]`) as HTMLAnchorElement;
        if (link) {
            link.classList.remove('text-muted-foreground');
            link.classList.add('bg-primary/5', 'text-primary', 'font-medium', 'border-l-2', 'border-primary');
            this.activeLink = link;

            // Scroll only the TOC container (not the page) to keep active link visible
            const tocList = document.getElementById('toc-list');
            if (tocList) {
              const linkTop = link.offsetTop;
              const listHeight = tocList.clientHeight;
              tocList.scrollTo({
                top: linkTop - listHeight / 2 + link.clientHeight / 2,
                behavior: 'smooth'
              });
            }
        }
    }
    
    public destroy() {
        this.observer.disconnect();
    }
  }

  // Handle scroll propagation for TOC
  function setupTocScrollPropagation() {
    const tocList = document.getElementById('toc-list');
    if (!tocList) return;

    tocList.addEventListener('wheel', (e: WheelEvent) => {
      const { scrollTop, scrollHeight, clientHeight } = tocList;
      const hasScrollableContent = scrollHeight > clientHeight;
      
      // If TOC has no scrollable content, just let the event propagate naturally
      if (!hasScrollableContent) {
        return;
      }

      const atTop = scrollTop <= 0;
      const atBottom = scrollTop + clientHeight >= scrollHeight - 1;
      const scrollingUp = e.deltaY < 0;
      const scrollingDown = e.deltaY > 0;

      // If at limits and trying to scroll beyond, don't prevent default
      // This allows the page to scroll
      if ((scrollingUp && atTop) || (scrollingDown && atBottom)) {
        return;
      }

      // Only prevent default (stop page scroll) if TOC can actually scroll in this direction
      e.preventDefault();
    }, { passive: false });
  }

  // Init
  let toc: TableOfContents | null = null;
  
  function init() {
      if (toc) toc.destroy();
      toc = new TableOfContents();
      setupTocScrollPropagation();
  }

  document.addEventListener('astro:page-load', init);
</script>
