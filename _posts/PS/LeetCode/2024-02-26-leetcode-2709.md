---
title: "[LeetCode] 2709. Greatest Common Divisor Traversal"
excerpt: "ë¦¬íŠ¸ì½”ë“œ 2709 - íŒŒì´ì¬(Python) í’€ì´"

categories:
    - LeetCode
tags:
    - [Python, PS, Graph, BFS, ConnectedComponents]

date: 2024-02-26
last_modified_at: 2024-02-26

toc: true
toc_sticky: true
related: true
---

<div class="notice--info" markdown="1">
ğŸ‘¨â€ğŸ’» ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ ì…ë‹ˆë‹¤. <br/>
ğŸ’¡ í‹€ë¦° ë‚´ìš©ì´ë‚˜ ì˜¤íƒ€ëŠ” ëŒ“ê¸€, ë©”ì¼ë¡œ ì œë³´í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤!!  (__)
</div>

# ë§í¬

<https://leetcode.com/problems/greatest-common-divisor-traversal/description/?envType=daily-question&envId=2024-02-25>

# ë¬¸ì œ

<div class="elfjS" data-track-load="description_content"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>, and you are allowed to <strong>traverse</strong> between its indices. You can traverse between index <code>i</code> and index <code>j</code>, <code>i != j</code>, if and only if <code>gcd(nums[i], nums[j]) &gt; 1</code>, where <code>gcd</code> is the <strong>greatest common divisor</strong>.</p>

<p>Your task is to determine if for <strong>every pair</strong> of indices <code>i</code> and <code>j</code> in nums, where <code>i &lt; j</code>, there exists a <strong>sequence of traversals</strong> that can take us from <code>i</code> to <code>j</code>.</p>

<p>Return <code>true</code><em> if it is possible to traverse between all such pairs of indices,</em><em> or </em><code>false</code><em> otherwise.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre><strong>Input:</strong> nums = [2,3,6]
<strong>Output:</strong> true
<strong>Explanation:</strong> In this example, there are 3 possible pairs of indices: (0, 1), (0, 2), and (1, 2).
To go from index 0 to index 1, we can use the sequence of traversals 0 -&gt; 2 -&gt; 1, where we move from index 0 to index 2 because gcd(nums[0], nums[2]) = gcd(2, 6) = 2 &gt; 1, and then move from index 2 to index 1 because gcd(nums[2], nums[1]) = gcd(6, 3) = 3 &gt; 1.
To go from index 0 to index 2, we can just go directly because gcd(nums[0], nums[2]) = gcd(2, 6) = 2 &gt; 1. Likewise, to go from index 1 to index 2, we can just go directly because gcd(nums[1], nums[2]) = gcd(3, 6) = 3 &gt; 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre><strong>Input:</strong> nums = [3,9,5]
<strong>Output:</strong> false
<strong>Explanation:</strong> No sequence of traversals can take us from index 0 to index 2 in this example. So, we return false.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre><strong>Input:</strong> nums = [4,3,12,8]
<strong>Output:</strong> true
<strong>Explanation:</strong> There are 6 possible pairs of indices to traverse between: (0, 1), (0, 2), (0, 3), (1, 2), (1, 3), and (2, 3). A valid sequence of traversals exists for each pair, so we return true.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>

# ë¬¸ì œ ì„¤ëª… ë° ìš”ì 

- 10ë§Œ ì´í•˜ì˜ ì–‘ìˆ˜ë¡œ ì´ë£¨ì–´ì§„ ë°°ì—´ì´ ì£¼ì–´ì§„ë‹¤. 
- í˜ì–´ì— ëŒ€í•´ ìµœëŒ€ê³µì•½ìˆ˜ê°€ 1 ì´ìƒì´ë¼ë©´, ë‘ ìˆ«ìë¼ë¦¬ ìˆœíšŒê°€ ê°€ëŠ¥í•œ ê²ƒìœ¼ë¡œ ì·¨ê¸‰í•œë‹¤.
- ì£¼ì–´ì§„ ë°°ì—´ì— ìˆëŠ” ëª¨ë“  ìˆ«ìë¥¼ ìˆœíšŒ ê°€ëŠ¥í•œì§€ ì—¬ë¶€ë¥¼ ì²´í¬í•œë‹¤.

# í’€ì´

> #ìˆ˜í•™ #ìœ í´ë¦¬ë“œí˜¸ì œë²• #ê·¸ë˜í”„ #Union-find #BFS 

- ì—£ì§€ ì¼€ì´ìŠ¤ê°€ ê½¤ ìˆì–´ í™”ë‚˜ëŠ” ë¬¸ì œ. -> `[1, 1]`ì€ Falseì¸ë°, `[1]`ì€ True ì´ë‹¤.
- ì²˜ìŒì—ëŠ” ê° í˜ì–´ ë³„ë¡œ GCD(ìµœëŒ€ ê³µì•½ìˆ˜)ë¥¼ ëª¨ë‘ êµ¬í•´ë³´ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í–ˆë‹¤.
	- GCDê°€ 1 ì´ìƒì´ë©´, Union-find ë¥¼ í†µí•´ ê°™ì€ ì»´í¬ë„ŒíŠ¸ë¡œ ì—°ê²°ì‹œì¼œì£¼ì—ˆë‹¤.
	- ì¼ë‹¨ ê° í˜ì–´ë¥¼ ëª¨ë‘ ê³„ì‚°í•´ë³´ëŠ”ê²Œ \\( O(N^2) \\) ì´ê³ , Union-findì—ë„ ì¶”ê°€ ë¹„ìš©ì´ ë°œìƒí•˜ë¯€ë¡œ ì‹œê°„ì´ˆê³¼.
- ë„ì €íˆ ì¤„ì¼ ë°©ë²•ì´ ìƒê°ì´ ì•ˆë‚˜ì„œ, íŒíŠ¸ë¥¼ ëª¨ë‘ ì—´ì–´ ì°¸ê³ í–ˆë‹¤.
	1. ê° ì¸ë±ìŠ¤ì— ëŒ€í•´ ì†Œì¸ìˆ˜ ë¦¬ìŠ¤íŠ¸ ì‘ì„±
	2. ì†Œì¸ìˆ˜ ë¦¬ìŠ¤íŠ¸ì— ëŒ€í•´ ì´ì›ƒë¼ë¦¬ ì—£ì§€ ìƒì„±. ìˆœì„œëŠ” ì¤‘ìš”ì¹˜ ì•ŠìŒ. ëª¨ë“  í˜ì–´ì˜ ì—£ì§€ë¥¼ ê²€ì‚¬í•˜ê¸° ë³´ë‹¤ëŠ”, ë‘ ì´ì›ƒê°„ ì—£ì§€ë§Œ ìˆìœ¼ë©´ ëœë‹¤.
	3. ì´ì œ ì´ ë¬¸ì œëŠ” ëª¨ë“  ìˆ«ì(ê·¸ë˜í”„ì˜ ë…¸ë“œ)ê°€ ë™ì¼í•œ ì—°ê²°ëœ ì»´í¬ë„ŒíŠ¸ì— ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ê²ƒê³¼ ìœ ì‚¬í•¨.
	4. ì—°ê²°ëœ ì»´í¬ë„ŒíŠ¸ë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ (BFS, DFS, Union-find ë“±) ì€ ëª¨ë‘ ìœ íš¨í•¨
- 'ê·¸ë˜í”„ ë¬¸ì œë¡œ ëª¨ë¸ë§ í•  ìˆ˜ ìˆëŠ”ê°€?' ê°€ í•µì‹¬ì¸ ë¬¸ì œ ê°™ë‹¤.
	- 'ìˆœíšŒ ê°€ëŠ¥í•œì§€' ì²´í¬í•˜ëŠ” ë¶€ë¶„ì—ì„œ ì—°ê²°ëœ ì»´í¬ë„ŒíŠ¸ ì°¾ê¸°ë¥¼ ë– ì˜¬ë ¸ì–´ì•¼ í•œë‹¤.
	- í•˜ì§€ë§Œ ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ì— ëŒ€í•´ ì¼ì¼ì´ GCDë¥¼ ê³„ì‚°í•´ë³´ë©° ì´ì„ ê²ƒì¸ê°€?
- ê° ìˆ«ìë¥¼ í•œ ë²ˆì”©ë§Œ ë³´ê³ ë„ ì •ë‹µì„ êµ¬í•  ìˆ˜ ìˆë‹¤.
	- ì–´ë–¤ ìˆ«ìë¥¼ ì†Œì¸ìˆ˜ ë¶„í•´ í–ˆì„ ë•Œ, ì§€ìˆ˜ë¥¼ ì œì™¸í•œ ë°‘ì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ `ì¸ìˆ˜ ë¦¬ìŠ¤íŠ¸`ë¼ê³  í•˜ì.
	- `ì¸ìˆ˜ ë¦¬ìŠ¤íŠ¸`ì— ì†í•˜ëŠ” ìˆ«ìë¼ë¦¬ëŠ” ì´ì„ ìˆ˜ ìˆë‹¤.
	- ë§Œì•½ [2, 3, 6]ì´ ì¡´ì¬í•˜ê³  6ì„ ì†Œì¸ìˆ˜ ë¶„í•´ í•˜ì—¬ [2, 3]ì„ ì–»ì€ ìƒí™©ì´ë¼ë©´, 2ì™€ 3ì„ ì´ì„ ìˆ˜ ìˆê²Œ ë˜ëŠ” ê²ƒì´ë‹¤. 
	- ì¸ìˆ˜ë¡œ 2ë¥¼ ê°€ì§€ëŠ” ì–´ë–¤ ìˆ«ìì™€ 3ì„ ê°€ì§€ëŠ” ì–´ë–¤ ìˆ«ìëŠ” í˜„ì¬ ìˆ«ìë¥¼ ì¤‘ê°„ ë…¸ë“œë¡œ ë‘ê³  ë°©ë¬¸í•  ìˆ˜ ìˆë‹¤ëŠ” ëœ»ì´ ëœë‹¤.
	- ëª¨ë“  ìˆ«ìì— ëŒ€í•´ `ì¸ìˆ˜ ë¦¬ìŠ¤íŠ¸` ë¥¼ êµ¬í•˜ì—¬ ê·¸ë˜í”„ë¥¼ ìƒì„±í–ˆë‹¤ë©´, ì´ ê·¸ë˜í”„ê°€ í•˜ë‚˜ì˜ ì»´í¬ë„ŒíŠ¸ì¸ì§€ ê²€ì‚¬í•˜ë©´ ëœë‹¤.
- ì›ë¦¬ë¥¼ ì•Œì•„ë„ êµ¬í˜„í•˜ê¸° ì‰½ì§€ ì•Šì•˜ë‹¤.
	- í¬ê²Œ "1. íŠ¹ì • ìˆ«ìë¥¼ ì†Œì¸ìˆ˜ë¶„í•´ í•˜ì—¬ `ì¸ìˆ˜ ë¦¬ìŠ¤íŠ¸` ë¥¼ êµ¬í•˜ê³ , ê·¸ë˜í”„ë¡œ ëª¨ë¸ë§í•˜ê¸°" ì™€ "2. ê·¸ë˜í”„ê°€ í•˜ë‚˜ì˜ ì»´í¬ë„ŒíŠ¸ë¡œ ì¡´ì¬í•˜ëŠ”ì§€ ê²€ì‚¬í•˜ê¸°" íŒŒíŠ¸ë¡œ ë‚˜ëˆ„ì—ˆë‹¤.
	- ê¸°ë³¸ì ì¸ [ì†Œì¸ìˆ˜ë¶„í•´ ì•Œê³ ë¦¬ì¦˜](https://namu.wiki/w/%EC%86%8C%EC%9D%B8%EC%88%98%EB%B6%84%ED%95%B4/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98#:~:text=%5B%ED%8E%B8%EC%A7%91%5D-,2.1.,-%EA%B8%B0%EC%B4%88)ì„ í†µí•´ `ì¸ìˆ˜ ë¦¬ìŠ¤íŠ¸`ë¥¼ êµ¬í•˜ì˜€ë‹¤. 3ë¶€í„°ëŠ” 2ì”© ì í”„í•´ë„ ë˜ê³ , ì´ˆê¸° ìˆ«ìì˜ ì œê³±ê·¼ ë§Œí¼ë§Œ ëŒì•„ë„ ëœë‹¤.
	- ë‹¤ë§Œ ì œê³±ê·¼ ë§Œí¼ë§Œ ëˆë‹¤ë©´, ë§ˆì§€ë§‰ ì—°ì‚° ê²°ê³¼ê°€ 2 ì´ìƒì¸ì§€ ê¼­ ì²´í¬í•´ë´ì•¼ í•œë‹¤. 1ì´ ì•„ë‹ˆë¼ë©´ ë§ˆì§€ë§‰ ì†Œì¸ìˆ˜ê°€ ëœë‹¤.
	- ì´ë¥¼ `set`ì„ í†µí•´ ê·¸ë˜í”„ë¡œ ëª¨ë¸ë§í•´ì£¼ì—ˆë‹¤.
	- `ì¸ìˆ˜ ë¦¬ìŠ¤íŠ¸`ì— ì†í•˜ëŠ” ëª¨ë“  ìˆ«ìì— ëŒ€í•´ `ì¸ìˆ˜ ë¦¬ìŠ¤íŠ¸ - {ìˆ«ì}` ë¥¼ í•˜ë©´, `set`ì´ê¸° ë•Œë¬¸ì— íŠ¹ì • ìˆ«ìë§Œ ë¹ ì§„ ì§‘í•©ì„ ì–»ì„ ìˆ˜ ìˆë‹¤.
	- ì´ë¥¼ `defaultdict(set)`ì— ì¡´ì¬í•˜ëŠ” ê¸°ì¡´ ì§‘í•©ê³¼ì˜ í•©ì§‘í•© ì—°ì‚°ì„ í†µí•´ í•©ì¹œë‹¤.
	- ìµœì¢…ì ìœ¼ë¡œ, `key`ëŠ” ì†Œì¸ìˆ˜ ì¤‘ í•˜ë‚˜, `value`ëŠ” í•´ë‹¹ ì†Œì¸ìˆ˜ì™€ ì´ì–´ì§„ ë‹¤ë¥¸ ì†Œì¸ìˆ˜ì˜ `set`ì´ ëœë‹¤.
	- ì´ë ‡ê²Œ êµ¬í•œ ê·¸ë˜í”„ëŠ” ì—¬ëŸ¬ ë°©ë²•ì„ í†µí•´ í•˜ë‚˜ì˜ ì»´í¬ë„ŒíŠ¸ë¡œ ì—°ê²°ë˜ì—ˆëŠ”ì§€ ê²€ì‚¬í•  ìˆ˜ ìˆë‹¤. ë‚œ BFSë¥¼ ì‚¬ìš©í•˜ì˜€ë‹¤.
	- `key`ì˜ ë§¨ ì²˜ìŒ ê°’ì„ ê°€ì ¸ì™€ì„œ í•´ë‹¹ ê°’ìœ¼ë¡œ BFSë¥¼ 1íšŒ ìˆ˜í–‰í•˜ê³ , ë°©ë¬¸í•˜ì§€ ì•ŠëŠ” ë‹¤ë¥¸ ë…¸ë“œê°€ ìˆë‹¤ë©´ Falseë¥¼, ì—†ë‹¤ë©´ Trueë¥¼ ë°˜í™˜í•˜ì˜€ë‹¤.
	- ë°©ë¬¸í•œ ë…¸ë“œë¥¼ ì €ì¥í•˜ëŠ” `set`ê³¼ ê¸°ì¡´ `key`ì™€ì˜ êµì§‘í•©ì„ êµ¬í–ˆì„ ë•Œ ê¸°ì¡´ `key`ê°€ ê·¸ëŒ€ë¡œ ë‚˜ì˜¤ëŠ” ì§€ ê²€ì‚¬í•˜ë©´ ëœë‹¤.
- í’€ê³  ë‚˜ë‹ˆ êµ¬í˜„ì´ ë” ê°„ë‹¨í•œ í’€ì´ë²•ì´ ì¡´ì¬í–ˆë‹¤. ì•„ë§ˆ íŒŒì´ì¬ë§Œ ê°€ëŠ¥í•  ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤.
	- ì£¼ì–´ì§„ ìˆ«ìë¥¼ ì¤‘ë³µ ì œê±° í›„ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬í•œë‹¤.
	- ê¸°ë³¸ì ìœ¼ë¡œ ê° í˜ì–´ì˜ GCDë¥¼ ê²€ì‚¬í•  ê²ƒì´ë‹¤. í•˜ì§€ë§Œ ê²€ì‚¬ íšŸìˆ˜ë¥¼ í™• ì¤„ì¼ ìˆ˜ ìˆë‹¤.
	- í•˜ë‚˜ì˜ ê¸°ì¤€ì (`i`)ì„ ì¡ê³ , í•´ë‹¹ ìˆ«ìì˜ ì˜¤ë¥¸ìª½(`j: i+1 ... N`)ë§Œ ë³¸ë‹¤.
		- ë‘ ìˆ«ìì˜ GCDë¥¼ ê²Œì‚°í•˜ì—¬ 1ë³´ë‹¤ í¬ë‹¤ë©´, "ê¸°ì¤€ì ì— ìˆë˜ ìˆ«ì(`nums[i]`)ë¥¼ GCDë¡œ ë‚˜ëˆˆ ê°’"ì„ í˜ì–´ë¥¼ ì´ë£¨ëŠ” ìˆ«ì(`nums[j]`)ì— ê³±í•˜ì—¬ ì €ì¥í•œë‹¤.
		- ì´ëŠ” ì¸ìˆ˜ë¥¼ ë’· ìˆ«ìì— ìŒ“ì•„ë²„ë¦¬ëŠ” íš¨ê³¼ê°€ ìˆë‹¤. (ìˆ˜ê°€ êµ‰ì¥íˆ ì»¤ì§ˆ ìˆ˜ ìˆì§€ë§Œ, `ì¸ìˆ˜ ë¦¬ìŠ¤íŠ¸` ë¥¼ ì´ì–´ ê·¸ë˜í”„ë¥¼ ìƒì„±í•˜ëŠ” ê²ƒê³¼ ê°™ì€ íš¨ê³¼ì´ë‹¤.)
		- ë‹¤ìŒ ê¸°ì¤€ì (`i++`)ìœ¼ë¡œ ì´ë™í•œë‹¤.
	- `j`ê°€ ëê¹Œì§€ ëŒì•˜ëŠ”ë°ë„ `i`ì— ìˆëŠ” ìˆ«ìë¥¼ ìŒ“ì„ ìˆ˜ ì—†ë‹¤ë©´, ì´ ìˆ«ìëŠ” ì–´ë– í•œ ìˆ«ìì™€ë„ ì—°ê²°í•  ìˆ˜ ì—†ë‹¤ëŠ” ëœ»ì´ ë˜ë¯€ë¡œ ë°”ë¡œ Falseë¥¼ ë¦¬í„´í•  ìˆ˜ ìˆë‹¤.

# ì½”ë“œ

```python
from collections import defaultdict
from collections import deque

class Solution:
    def getPrimeFactorEdges(self, primeFactorList: dict[set], num: int) -> None:
        factor = set()
        origin = num
        while num % 2 == 0:
            factor.add(2)
            num //= 2
        
        for i in range(3, int(origin ** 0.5) + 2, 2):
            while num % i == 0:
                factor.add(i)
                num //= i

        if num >= 2:
            factor.add(num)

        for f in factor:
            primeFactorList[f] |= factor - {f}

    def isAllConnected(self, primeFactorList: dict[set]) -> bool:
        visited = set()
        start = list(primeFactorList.keys())[0]
        q = deque([start])
        visited.add(start)
        while q:
            prev = q.popleft()
            for curr in primeFactorList[prev]:
                if curr not in visited:
                    visited.add(curr)
                    q.append(curr)

        return visited & primeFactorList.keys() == primeFactorList.keys()


    def canTraverseAllPairs(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return True
        if 1 in set(nums):
            return False

        primeFactorList = defaultdict(set)
        
        for num in nums:
            self.getPrimeFactorEdges(primeFactorList, num)

        return self.isAllConnected(primeFactorList)
```

```python
from math import gcd

class Solution:
    def canTraverseAllPairs(self, nums: List[int]) -> bool:
        if 1 in nums and len(nums) > 1: return False

        nums = sorted(list(set(nums)), reverse=True)

        LEN = len(nums)
        for i in range(LEN-1):
            for j in range(i+1, LEN):
                temp = gcd(nums[i], nums[j])
                if 1 < temp:
                    nums[j] *= nums[i] // temp
                    break
            else:
                return False
        return True
```
