---
title: "딥러닝이란 무엇일까?"
excerpt: "기본적인 신경망과 하위 분류를 알아보자"

categories:
    - DL
tags:
    - [DeepLearning, Optimization, CV, NLP]

date: 2023-12-10
last_modified_at: 2024-01-01

toc: true
toc_sticky: true
related: true
---

## 시작하기 전

글또 제출 겸, 시험 공부 겸, 학부과정에서 배우는 딥러닝에 대한 개괄적인 내용을 정리하기 위한 글입니다. 공부해보신 분들은 목차만 보시더라도 절대 하나의 페이지에 담을만한 분량이 아니라는 것을 잘 아시겠지만, 그래도 저는 해야만 합니다... 각 토픽에 대한 상세한 내용은 추후에 정리해보도록 하고, 이 글에서는 흐름 정도만 짚어보도록 하겠습니다!

## Prerequisite

-   대학수학 수준의 미적분학(Chain Rule, Gradient)과 최적화 이론(선형 계획법, 비선형 계획법)을 일부 포함하고 있다.
-   머신 러닝의 하위 분류(지도학습, 비지도학습, 준지도학습)에 대해 알고 있으면 좋다.
    - 정말 간단히 이야기하면 지도학습은 답지가 있고, 비지도학습은 답지가 없고, 준지도학습은 지도학습 + 비지도학습 이다.
-   딥러닝을 시각화한 아주 훌륭한 영상이 있다! [3Blue1Brown 의 딥러닝 시리즈](https://youtu.be/aircAruvnKk?si=c4TcRCgXcF2BNNsJ)를 보면 딥러닝에 대한 기본적인 키워드를 모두 알 수 있고, Backpropagation에 대해 확실히 이해할 수 있다. 그러나 행렬과 미적분에 대한 선행 지식이 없다면 영상 자체가 쉽지 않을 수 있다.
-   선수 지식이 필수는 아니다! 최대한 쉽게 쓰려고 노력했으니 그냥 한 번 찍어 먹어보는 것도 괜찮을 것 같다.

## Perceptron

퍼셉트론(Perceptron)은 Perception + Neuron의 합성어로, 쉽게 이야기하면 인공 뉴런이다. 생물학적인 신경계의 기본 단위인 신경세포를 모방하여 입력(=자극)을 받고, 그것이 일정 수준을 넘으면 출력을 내보내는 방식이다. 아래와 같이 시각화 할 수 있으며, \\( x_1, x_2, x_3 \\) 를 입력으로 받고 \\( y \\) 를 출력으로 내보낸다. \\( w_1, w_2, w_3 \\) 는 각 입력에 대한 가중치로 작동한다. 정리하면 \\( x_1 * w_1 + x_2 * w_2 + x_3 * w_3 \\) 이 일정 수준을 넘으면 특정한 \\( y \\) 값이 나오는 구조이다.

![Perceptron Structure](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/d983f3f6-5d6c-4e56-bb97-bc4129c19e25)

입력으로 편향(bias)이 들어갈 수 있는데, 이는 넘어가도록 하자. 퍼셉트론은 분류 문제를 풀기 위해 고안되었는데, 분류 문제는 결과가 이산적인 특정 값(0, 1, ...)이 나와야 한다. 연속적인 값(실수, 0.1231...)은 존재할 수 없다. 하지만 위에 써놓은 수식이 항상 이산적인 값이 나온다고 보장할 수 있을까? 당연히 없다. 가중치 값들이 연속적인 값일 수 있기 때문이다. 그렇다면 \\( y \\) 값이 항상 이산적이도록 하려면 어떻게 해야할까?

활성화 함수(Activation Function)라는 것을 사용하면, 연속적인 값을 항상 이산적인 값으로 바꿔줄 수 있다. 활성화 함수를 어떤 것을 사용하느냐에 따라 다르겠지만, 제일 간단한 계단 함수를 알아보자.

\\[
H(x) = \displaystyle \begin{cases}
0 & \text{if } x < 0 \\\\  
1 & \text{if } x \geq 0
\end{cases}
\\]

0보다 작을 때는 0이, 그 반대의 경우에는 1이 나오는 함수이다. 이 함수에는 어떤 값을 집어넣어도 0아니면 1이 나온다. 지금까지 언급한 내용을 한 장으로 정리하면 아래와 같다.

![Perceptron with Activation](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/d349280c-73ec-4cd2-871b-4cb16eaecaf4)

머신러닝과 딥러닝 분야에서 `학습` 이라는 단어가 자주 쓰이는 것은 잘 알려져있다. 딥러닝에서의 `학습` 이라는 것은 결국 위에서 언급한 퍼셉트론의 가중치(weight)와 편향(bias)을 찾는 작업이다. 가중치 하나하나를 파라미터(Parameter) 라고 한다. "GPT4의 파라미터의 개수가 약 1조개 이다." 할 때의 파라미터와 같다. 지도학습에서는 특정 입력 \\( x_1, x_2, ... \\) 에 대한 출력 \\( y \\) 을 알고 있으므로, 여러 개의 입력 세트에 대해 적절한 출력을 내도록 계산을 반복하여 가중치를 찾는다고 이해하면 적절하다. 이렇게 학습한 퍼셉트론은 AND, OR과 같은 간단한 문제는 잘 해결한다. 

AND와 OR 같은 경우는 프로그래밍에서 잘 알려져 있는 것과 같다. 모두 `True`인 경우에만 결과가 `True`이면 AND이고, 하나만 `True`여도 결과가 `True`이면 OR이다. 눈치가 빠른 사람은 알겠지만, 퍼셉트론을 학습 시키면 결국 직선이 나온다. AND, OR 분류 문제는 직선 하나로 해결 가능하기 때문에, 하나의 퍼셉트론으로 충분하다.

![Perceptron Boundary](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/abe1f54b-b852-41cb-ae41-1f0c0c87afd0)

하지만, XOR 문제 같이 하나의 직선으로 절대 분류할 수 없는 경우는 어떻게 할까?

![XOR Problem](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/a5653504-63a9-497b-be21-3c2696a4feda)

### XOR Problem

위 사진으로 알 수 있듯, XOR은 모두 `True`이거나 모두 `False`이면 결과가 `False`, 그 반대의 경우에는 `True`인 문제이다. ~~하나의 직선으로 XOR의 `True` 영역과 `False`를 구분한다면 당신은 노벨상을 받게 될 것이다.~~ 하나의 퍼셉트론으로 해결할 수 없다면, 여러 개를 사용하면 어떨까?

![XOR Network](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/b77b60d6-003d-4418-bd36-5134acc0306d)

이렇게 뉴런을 2개 사용하면, 비선형적인 분류가 가능해진다. 이에 대한 자세한 설명은 [링크](https://medium.com/analytics-vidhya/multi-layer-perceptron-as-a-non-linear-classifier-03-8cd25147fc23)를 참조하자. 여기서는 '퍼셉트론을 한 번에 여러 개 사용할 수 있구나!' 정도만 이해하고 넘어가자.

### Multi Layer Perceptron

관찰력이 좋은 사람이라면 위 사진에서 뉴런에 Hidden이라고 써있는 것을 발견했을 것이다. 딥러닝에서 흔히 언급되는 키워드로 Hidden Layer가 있는데, 단어를 하나씩 뜯어보자. Hidden 이라는 것은 말 그대로 보이지 않는다는 뜻이다. Layer는 흔히 이야기하는 그 레이어와 완전 똑같다. 입력층(Input Layer)과 출력층(Output Layer) 사이에 있는 모든 퍼셉트론 들을 은닉층(Hidden Layer)이라고 한다. 

![MLP](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/8c2854eb-fa38-4102-b4ac-68a8c2ac1be6)

이렇게 입력층-은닉층-출력층 으로 이루어진 구조를 다층 퍼셉트론(Multi Layer Perceptron)이라고 한다. 다층 퍼셉트론은 인공신경망이라고도 불리고, 보통 은닉층이 3개 이상이면 딥러닝이라고 부르는 것 같다. 은닉층은 여러 개일 수 있고, 하나의 은닉층 안에는 여러 개의 퍼셉트론이 있을 수 있다. 위 사진도 엄청 복잡한 구조 같지만, MLP에서는 매우 간단한 편이다. 각 층에서는 퍼셉트론 파트에서 설명한 일이 매번 일어난다. 입력을 받고, 계산하여 임계값을 넘는지 확인하고, 특정 값을 출력한다. 

## Training MLP

앞서 퍼셉트론이 무엇인지, 무엇을 `학습`하는지, 다층 퍼셉트론 구조가 어떻게 되는지 알아보았다. 다층 퍼셉트론의 학습도 원리는 별반 다르지 않다. ~~(과연 그럴까?)~~ 똑같이 각 퍼셉트론의 가중치와 편향들을 찾으면 된다. 은닉층이 적으면 일일이 계산하여 가중치 값을 찾을 수 있겠지만, 위 그림과 같은 형태만 되어도 쉽지 않다. 이를 타파할 새로운 방법이 필요하다.

우리의 목적은 결국 다층 퍼셉트론 모델이 정답을 맞추도록 학습 시키는 것이다. 이를 위해서 모델이 예측한 값과 실제 정답 간의 차이(오차)를 나타내는 `손실 함수(Loss Function)`를 정의해보자. (더 쉽게 이야기하면, '모델이 얼마나 틀렸는가?'를 수치화 하는 함수이다.) 매 학습마다 이 손실 함수의 값을 찾고, 이를 줄이는 방향으로 학습하면 더 간단하지 않을까? 이러한 방법을 (오차)역전파(Backpropagation) 라고 한다. ~~(역전v파 가 아니라 역v전파)~~ 참고로, 입력층으로부터 출력층 방향으로 학습하는 것을 순전파(Forward Propagation) 라고 한다. 

고등 수학에서 함수의 최솟값 또는 최댓값을 찾기 위해 미분을 했던 것이 기억나는가? 미분하여 0이 되는 지점을 찾고, 해당 지점을 극대/극소 라고 불렀다. 물론 해당 지점이 함수의 최솟값 또는 최댓값이라는 보장은 없다. 미분을 통해 알 수 있는 사실은 특정 지점에서의 `추세` 이다. 미분값은 어떠한 지점에서 함수값이 증가하고 있었는지 감소하고 있었는지를 나타낸다. 고등 수학에서는 하나의 변수 \\( x \\)를 가지는 함수에 대해 다뤘었지만, 우리가 지금 찾고자 하는 것은 변수가 여러 개인 다변수 함수이다. 다변수 함수의 미분값을 그래디언트(Gradient)라고 한다. 손실 함수의 값을 줄이는 방향은 그래디언트가 음수일 것이며, 그래디언트가 0에 가까워지는 지점을 찾으면 오차를 최소화할 수 있을 것이다.

### Backpropagation

역전파는 학습 과정에서의 계산을 많이 줄여준다. 미적분학의 Chain Rule을 활용하면 계산 또한 재귀적으로 수행할 수 있다. 그러나 순전파에 비해 계산량이 적을 뿐이지, 여전히 많다. 따라서 더 줄일 방법이 필요하다. 

먼저, 역전파 수행 과정을 정리해보자.
1. 가중치를 랜덤으로 초기화 한다.
2. 특정 학습 데이터를 넣어 예측값을 뽑아낸다.
3. 손실 함수를 통해 오차를 계산한다.
4. 출력층으로 부터 신경망을 거꾸로 거슬러 올라가며, 손실함수의 그래디언트를 통해 각 오차의 추세를 계산하고, 가중치를 업데이트한다.
    - 새 가중치 = 이전 가중치 - (학습률 * 그래디언트)
5. 2~4 과정을 가중치가 수렴할 때까지 반복한다.

2번 과정에서 전체 학습 데이터셋을 넣어 학습하는 것을 `Batch Gradient Descent` 라고 한다. 이는 계산 집약적이라서 실용적이지 않다. 학습 데이터셋에서 랜덤하게 특정 데이터를 골라가며 학습 과정을 거치는 것을 `Stochastic Gradient Descent`라고 한다. 이는 계산이 매우 간단해지지만, 노이즈가 심하다. 학습 데이터셋에서 특정한 크기의 미니 배치 \\( B \\)를 추출하여 학습 과정을 거치는 것을 `Mini-batch Gradient Descent`라고 한다. 계산도 빠르고, 노이즈도 줄일 수 있는 방법이다.

### Non-linear Activation & Learning rate

앞서 활성화 함수에 대한 개념을 짚어보았는데, 구간마다 함수가 다르게 정의되므로 선형함수에 비해 계산이 복잡할 것 같다는 생각이 든다. 그러나 선형함수를 활성화 함수로 사용하면, Gradient Vanishing 문제를 해결할 수 없다.

Gradient Vanishing은 은닉층을 깊게 쌓을수록 그래디언트 값이 0으로 수렴하게 되어, 역전파를 통해 가중치를 업데이트할때 입력층에 가까운 퍼셉트론은 가중치가 업데이트 되지 않는 문제이다. 

따라서 활성화 함수로 비선형함수를 사용하여 그래디언트가 0으로 수렴하지 않도록 조절한다. 이러면 역전파 중 가중치가 업데이트 되지 않는 현상이 없어진다.

앞에서 역전파 과정을 설명할 때, 가중치를 업데이트하는 수식에 학습률이 있었다. 이 학습률을 통해 가중치의 학습 폭을 조절할 수 있다. 이 값이 적절하지 않으면 문제가 발생한다. 아래 사진을 보면 학습률이 너무 낮거나 높으면 어떻게 되는지 알 수 있다.

![learning rate](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/2c3d9640-c77a-45e2-bb14-de4528354f3a)

### Regularization

무조건 학습 데이터를 다 맞춘다고 좋은 것일까? 수능 특강을 너덜너덜 해질때까지 푼다고 해서, 수능을 잘 보진 않는다. 수능을 잘 볼 확률이 높아질 뿐이다. 머신러닝도 똑같다. 결국 가장 중요한 것은 일반화 성능이다. 학습 데이터에 과적합(Overfitting)되면, 일반화 성능이 낮아지게 된다. 수능에 조금만 변형된 문제가 나와도 틀리는 것과 같은 맥락이다.

매 학습 단계마다 일부 퍼셉트론을 아예 꺼버리는 `Dropout`이라는 방법론이 있다. 이는 딥러닝에서 일반적으로 쓰이는 테크닉으로, 대부분 좋은 결과를 가져온다. 랜덤으로 `Dropout`되는 퍼셉트론을 선택할 수 있고, 다른 알고리즘을 통해 선택할 수도 있다. 학습 과정에서만 퍼셉트론을 끄는 것이다. 학습 후 테스트 과정과는 관련이 없다!

일반화 성능을 위해 학습을 중단하는 `Early Stopping`이라는 것도 있다. 매 학습 단계마다 **Validation** 이라는 과정을 수행하여, Validation 오차가 갑자기 늘어나 버리는 시점에 학습을 중단한다.

## CNN (Convolution Neural Network)

### Problem Statement

앞서 딥러닝이 무엇이고, 기본 구조인 MLP에 대해, 그것을 학습하는 방법에 대해 알아보았다. MLP는 높은 퀄리티의 데이터와 충분한 연산력, 적당한 은닉층만 있으면 정말 많은 것을 분류할 수 있는 구조이다. 하지만, 이미지의 경우에도 그럴까? 이미지에 있는 특정 물체가 어떤 것인지 분류하는 작업을 생각해보자."이미지도 픽셀 하나하나를 입력으로 넣고 학습 시키면 되지 않나요?" 아주 정확하다. 하지만 문제가 좀 있다.

보면 눈이 침침해지는 것 같은 화질인 480p(640x480)만 해도 픽셀이 307,200개 이다. "오 별로 안되는데요?" 물론 흑백일 경우가 이렇고, RGB 채널을 사용한다면 3배 해주면 되겠다. 이러면 입력값이 약 100만개이다. 물론 짱짱한 컴퓨터와 함께라면 어떻게든 MLP를 학습시킬 수도 있을 것 같다. 그런데, 이렇게 학습한 MLP가 과연 좋은 성능을 보여줄까?

이미지를 픽셀단위로 분리하여 1차원으로 만드는 것을 Flatten이라고 하는데, Flatten을 하게 되면 이미지의 공간 정보를 활용할 수 없다. (10x10 크기 이미지가 있다고 생각해보면, Flatten했을 때 10번째 픽셀과 11번째 픽셀이 붙어있게 된다.) 또한, 기본적으로 MLP는 Fully-Connected 구조(각 층이 완벽하게 연결된 상태)를 띄기 때문에 이미지를 MLP로 분류하려면 학습시켜야 할 파라미터 수가 매우 많아지게 된다. 

이러한 문제점들을 해결하기 위해 고안된 구조가 바로 CNN(Convolution Neural Network)인데, 이를 알아보기 전에 먼저 Convolution이 무엇인지 알아보자.

### What is Convolution?

- 이것도 기가 막힌 시각화가 존재한다. [3Blue1Brown의 But what is a convolution?](https://www.youtube.com/watch?v=KuXjwB4LzSA) 다양한 Convolution 연산의 활용 예시를 알아볼 수 있다. 

흔히 합성곱 이라고도 불리는 Convolution 연산은 두 함수에 대한 연산으로, 하나의 함수가 다른 함수에 의해 표현되는 제 3의 함수를 생성하는 수학적 연산이다. 이게 무슨 소리인지 아래 움짤을 보자. 1차원 Convolution 연산에 대한 시각화 이다.

![Conv1d](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/3746f05e-c365-4d15-b6fc-bd39b09f6e12)

파란색 함수는 가만히 있고, 빨간색 함수가 움직이면서 새로운 검은색 함수를 생성해 내는 것을 알 수 있다. 노란 영역은 두 함수의 곱의 영역이라고 써져 있는데, 이는 Convolution이 적분으로 정의되기 때문이다.

\\[ \displaystyle (f*g)(t) = \int^\infty_{-\infty} f(\tau)g(t-\tau)d\tau \\]

그렇게 어려운 수식은 아니지만, 반드시 이해할 필요는 없다. 'Convolution은 두 함수를 합치는 연산이구나!' 정도만 이해하자. 이 연산은 이미지 처리에 상당히 많이 쓰이는데, 이는 나중에 따로 정리하도록 하겠다.

_(이 문단은 이해가 잘 안된다면 건너뛰자)_ <br>
좀 더 정확히 이야기하면, CNN에서 쓰이는 Convolution은 사실 Convolution이 아니다. Cross-Correlation이라는 연산이다. 연산에 쓰이는 함수 \\( g \\)를 커널(kernel) 이라고 하는데, Convolution은 명시적으로 커널을 뒤집는 (정의에서의 \\(g \\) 가 \\( g(t-\tau) \\) 형태로 되어 있던 이유이다. ) 과정이 필수적인데, 이미지 처리에서 쓰이는 커널은 뒤집나 그대로 두나 결과가 같다. 따라서 cross-correlation 이라는 연산을 사용하지만, 편의를 위해 Convolution이라고 부른다.

하지만 이미지는 1차원이 아니다. 따라서 함수가 아닌 행렬을 사용한다. 이미지를 행렬로 표현하고, 커널을 사용하여 새로운 행렬을 구하는 작업이 되는 것이다.

![conv2d](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/04938d1f-d02d-4ed4-a366-40218a690516)

위 예시에서의 아래 파란색 사각형을 보면 9x9 행렬로 이루어져 있다. 이를 3x3행렬이 움직여가면서 청록색 7x7 행렬을 채워가는 것을 볼 수 있다. 9x9 행렬을 이미지, 3x3 행렬을 커널(Kernel), 7x7 행렬을 Convolution 연산의 결과 라고 보면 된다. 이제 Convolution 연산의 결과 행렬을 Feature Map 이라고 부를 것이다.

### CNN Structures & Keys

CNN은 이미지의 지역적 특성을 학습하기 위한 딥러닝 접근법이다. 이미지에 대해 생각해보면, 의미있는 정보가 차지하는 공간은 생각보다 많지 않다. 480p의 고양이 이미지를 본다고 할 때, 약 30만개의 픽셀이 전부 고양이에 대한 정보는 아니라는 것이다. 

![CNN Structure](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/7a9d8fc9-d6c0-4d26-a8c2-150ac131a343)

따라서 Convolution 연산을 통해 이미지 정보가 압축된 Feature Map을 만들고, 이를 ReLU라는 활성화 함수를 통과 시켜서 의미 있는 정보를 살린다. (ReLU 또한 비선형 함수이기 때문에, MLP에서 비선형성을 추가하는 의미와 일맥상통한다.) 이 결과를 Pooling이라는 과정을 통해 행렬 크기(차원)를 줄인다.

위 과정을 수행하는 층을 Convolution Layer라고 한다. CNN은 Convolution Layer를 겹겹이 쌓고, 마지막에 Fully Connected Layer(=MLP)를 두어 이미지를 분류한다. 

CNN이 분류하고자 하는 것은 이미지 이지만, CNN이 학습하고자 하는 것은 커널이다. 이미지 프로세싱을 공부해본 사람은 Image Smoothing을 위한 커널이나 Edge Detection을 위한 커널을 본 적이 있을 것이다. CNN은 특정 물체를 인식하기 위한 커널을 학습한다. 즉, 커널 또한 가중치의 일부이다.

컬러 이미지를 학습한다고 할 때, 입력이 2차원이 아닌 최소 3차원일 것이다. (각 RGB 채널에 대한 픽셀 값) CNN은 학습의 효율성을 위해 채널별로 따로 학습하지 않고, 커널의 가중치를 공유하여 학습한다. 

앞서 Pooling이라는 과정으로 이미지 차원을 줄인다고 했는데, 이에 대한 예시를 하나 보자.

![Max Pooling](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/420e5f91-9c60-4e19-9c9c-dd5b66ffe063)

각 색깔에서 가장 큰 값을 가져와서 쓰는게 Max Pooling이다. 4x4 행렬이 2x2로 줄어든 것도 확인할 수 있다. 이러한 과정이 각 Convolution Layer에서 일어나면서 차원을 줄이고, 차원을 줄임으로써 학습할 파라미터가 줄게 된다.

Pooling 외에도 학습에 쓰이는 다양한 기법이 있는데, Padding과 Stride가 대표적이다. 간단하게만 짚고 넘어가자면, Padding은 Convolution 연산 과정에서 이미지의 본래 차원을 유지 시키기 위해 (어차피 Pooling으로 차원을 줄이니까, 커널 학습을 위해 Convolution 연산 간 이미지 차원을 유지시키는 것이다.) 사용하는 기법이다. Stride는 커널의 이동 칸 수를 조절하여 Feature Map의 크기를 줄이는 것이다. 아래 사진은 Stride가 2인 예시이다. 

![conv2d with stride 2](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/78f82b71-b6e2-4da3-aede-8f310351b37e)

## RNN (Recurrent Neural Network)

### Problem Statement

이미지를 효율적으로 학습할 수 있는 CNN에 대해서 알아보았다. 하지만 아직도 남아있는 문제가 있다. 과연 MLP나 CNN이 순서가 있는 순차적인 데이터를 학습할 때에도 적합할까?

시점 별 데이터들(스냅샷)을 가지고 분류 모델을 만들수야 있겠지만, 주가와 같이 동적인 특성(데이터가 추세를 갖거나, 특정 시점의 데이터가 그 이전 시점과 연관되는 경우)을 가진다면 적합하지 않다.

그러면 이전 시점의 N개의 데이터를 한 번에 입력으로 넣으면 되지 않을까? 이는 Gradient Vanishing 문제에 시달릴 수 있다. (짧게 언급하고 지나왔지만, MLP 구조가 가질 수 밖에 없는 문제점이다. 간단히 이야기하면, 은닉층이 깊어질 수록 앞 내용이 희석된다는 의미이다.) 

이러한 문제점들을 과연 어떻게 해결했을까??

### RNN Structures & Keys

RNN은 순차적인 데이터로부터 Recurrence와 Hidden State를 학습한다. 특정 \\( t \\) 시점의 Hidden State는 \\(t )\\ 시점의 데이터와 그 이전 시점 \\( t-1 )\\ 의 Hidden State로 결정된다. 그림으로 표현하면 아래와 같다. 

![RNN Structure](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/0265c744-fd8f-46c7-9f50-9baeffd66f41)

핵심을 쉽게 풀어보면, 신경망에 `메모리` 개념이 추가된 것이다. 이전 정보들을 기억하고, 현재 입력을 처리하는데에 이전 정보들을 꺼내와 사용한다. 이로 인해 데이터가 이전 시점에 의존성을 가져도 학습이 가능하다.

RNN은 CNN과 달리 순차적인 데이터의 흐름을 모델링하기 위해 설계되었으므로, 다양한 형태로 모델링이 가능하다. 아래 사진을 보자.

![RNN Modeling](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/65862ae2-4c62-45df-b780-a24fc3fba003)

제일 기본적인 형태를 one-to-one, Vanilla라고 한다. 다른 형태에 대한 활용은 사진을 참조하자. 문장이나 영상 같이 연속적이고 순차적인 정보를 담는 것을 입력이나 출력으로 넣는 것을 확인할 수 있다.

### LSTM (Long Short-Term Memory)

신경망이 장기적인 의존성을 가지는 데이터를 학습하려면 **Gradient Vanishing** 문제가 짙어진다고 했고, 이를 해결하기 위해 RNN 구조가 고안되었다고 했다. 그러나, RNN 구조 또한 **Gradient Vanishing** 문제로 부터 자유로울 수 없다. 예시를 하나 들어보자.

```text
I grew up in France, … and I speak fluent ______
```

위 문장을 사람이 봤을 때는, '아, 프랑스에서 자랐다고 했으니 프랑스어를 잘 하겠구나! 빈 칸에는 French가 들어가겠다' 라고 생각할 수 있다. 사이에 `...` 으로 요약된 부분이 길어지더라도, 사람은 똑같이 French라는 단어를 추론할 수 있을 것이다. 하지만 RNN은 그렇지 않다. `...` 부분이 길어질수록, 이전 정보들은 점점 희미해져서 정확한 예측을 하지 못하게 된다. 이러한 문제를 해결하기 위해서, LSTM(Long Short-Term Memory) 모델은 `Gate` 개념을 도입했다.

`Gate`는 특정 정보를 활용할지 제거할지 결정하는 구조이다. LSTM은 3개의 Gate를 활용한다. _Forget gate_ 는 이전 상태 정보를 저장할지를 결정하고, _input gate_ 는 입력되는 새로운 정보를 저장할지 결정하고, _output gate_ 는 갱신되는 출력값을 제어한다. 이러한 Gate들의 활용으로, 의미 없는 정보는 가중치를 적게 두어 쉽게 잊어버릴 수 있고, 중요한 정보는 가중치를 크게 두어 기억하도록 할 수 있다.

![RNN vs. LSTM](https://github.com/Tolerblanc/Tolerblanc.github.io/assets/52883827/753363ab-868e-4508-be5a-10182724dcb1)

위 구조는 RNN, 아래 구조는 LSTM이다. LSTM에서 \\( \sigma \\)로 표시된 유닛이 Gate이다. 구조가 좀 더 복잡해지는 대신, 긴 시퀀스를 모델링할 때는 훨씬 효과적이다.

## 마치며

원래 시험 범위는 이것 외에도 CNN구조를 차용한 현대 모델들이나 Transfer Learning, GAN, Self-Supervised Learning 등의 키워드가 포함되어 있지만, 분량이 너무 길어지기도 하고 이 글에 담기에는 너무 깊은 내용들이라고 생각하여 뺐다. 기회가 된다면 나중에 생성 모델과 함께 간단하게 정리해야겠다. 

나름 쉽게 적는다고 이것 저것 많이 제하고 표현을 수정한 것 같은데, 그래도 쉬워보이진 않는다. 블로그 글을 너무 오랜만에 적어서 그런 것도 있는 것 같다. 좀 더 자주 적을 수 있도록 해야겠다.